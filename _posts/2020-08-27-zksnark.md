---
layout: post
category: Zero Knowledge Proofs, Blockchain, ZCash
title: zk-SNARKs Explained with Bellman
---

### Trusted setup
Generate random field element **alpha** (α), **beta** (β), **gamma** (γ), **delta** (δ) and **tau** (τ).

We need to have two paring friendly curve, **G1** and **G2**, and pick two random points on each curve,
**g1** and **g2**.

A computation with **m** variables, of which **l** as public, **n** constraints
{% highlight bash %}
T(x) = (x-1)(x-2)(x-3)....(x-n-1)  # target polynomial
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
{% endhighlight %}

For prover, we need to have the following elements

{% highlight bash %}
# G1 elements
α, δ, 1,
τⁱ          # (i in 0..n-1)
Lᵢ(τ)/δ     # (i in l+1..m)
τⁱT(τ)/δ    # (i in 1..n-2)
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, δ, 1,
τⁱ          # (i in 0..n-1),
{% endhighlight %}

For the verifier, we need the following elements

{% highlight bash %}
# G1 elements
1,
Lᵢ(τ)/γ     # (i in 0..l),
{% endhighlight %}

{% highlight bash %}
# G2 elements
1, γ, δ
{% endhighlight %}

{% highlight bash %}
# Precomputed Gt element, in the paring domain
α₁ * β₂
{% endhighlight %}


[insert generator.rs:19]

| alpha | xxx |
| beta  | xxx |


the way to represent a R1CS

{% highlight rust %}
let mut assembly = KeypairAssembly {
    num_inputs: 0,
    num_aux: 0,
    num_constraints: 0,
    at_inputs: vec![],
    bt_inputs: vec![],
    ct_inputs: vec![],
    at_aux: vec![],
    bt_aux: vec![],
    ct_aux: vec![],
};
{% endhighlight %}

for each of the variables (element in FF), when we alloc_input or
alloc, we push an empty vector into `at_inputs`, `bt_inputs` and
`ct_inputs` or `at_aux`, `bt_aux` and `ct_aux`.

each of these empty vectors will be used to store constraints specific
for a variable, in the format of (coefficient, numOfConstrant).


this is how the R1CS is represented.


To recap, this is the original program we are trying to prove.

{% highlight c %}
// Flattened into quadratic equations
// (x^3 + x + 5 == 35):
x * x = tmp_1
tmp_1 * x = y
y + x + 5= out
{% endhighlight %}

after this point, R1CS is represetned in KeypairAssembly.

Now lets talk about powers_of_tau. If i understand correctly,
powers_of_tau should be τⁱ, i from 1 ~ number of constrants

first it is initiated to 5 zeros (we have 5 constraints here).

basically (2 ^ exp) number of constraints is the minimal number of
constraints that is in the form of 2ⁿ but bigger than the number of
constraints

in our case m = 2³, exp = 3, and the number of constraints are 5 (<2³)

and omega (ω) calculated as follows

{% highlight rust %}
// Compute omega, the 2^exp primitive root of unity
let mut omega = E::Fr::root_of_unity();
for _ in exp..E::Fr::S {
    omega.square();
}
{% endhighlight %}

omega = (g^t)^(2^(s - exp)), since root_of_unity as mentioned above is g^t.

omega = (g^t)^(2^s/2^exp)
      = (g^t)^(2^s) * (g^t)(1/(2^exp))
      = 1 * (g^t)(1/(2^exp))
      = (g^t)(1/(2^exp))

so basically: omege^(2^exp) = g^t = root_of_unity

then it calculates wnaf, which is a way to do perform exponantiation
on g in an efficient way

g1_wnaf.scalar(n) will calculate g1ⁿ in an efficient way.

same with g2_wnaf

then it calculates gamma_inverse (1/γ) and delta_inverse
(1/δ). because 1/δ is needed by the prover, and 1/γ is needed by the
verifier, as seen in the table above.

then we start to actually calculate the actual power of tau!!!!
and also T(x)

after line 244, power_of_tau should contain τⁱ (i in 1..2ᵐ where m is
2^exp)


then it calculates T(τ)/δ, which is needed as part of the proving key,
this is through coeff. perhaps the reason to call it a coeff is
because it is the coeff of τⁱT(τ)/δ. This is line generator.rs:245

from line generator.rs:249, it calculates H query, which is basically
{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ  # i in 0..n-1
{% endhighlight %}


Ok, now at generator.rs:275, now it is the interesting bit, why do we
need to do iFFT? what the result would be?
my guess is that it converts τⁱ to some kind of lagrange coefficients
which can be used later.

After line 278, it becomes a vector of points, with length 8, which is
2³. Fine.

At line 278, we are trying to get more variables.

variables: a, b_g1, b_g2, ic, l, looks like this is for setting
variables, since the length matches.

line 284, eval function, the purpose of this function is to evaluate
for normal input and aux input.

right now at_inputs, bt_inputs, and ct_inputs, are all in the lagrange
form, and also the power_of_tau is in lagrange form as well.

basically we are doing this. if variable polynomial x has (3, 2), (4,
7)  in an 8 steps constraints, 3 and 4 being coefficient, and 1, and 2
being the 2nd and 7th operation, then we basically do

3*(power_of_tau[2]) + 4*(power_of_tau[7])

and this is then the evaluation of a variable polynomial.

after this, it basically gives you this:

After the first eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in 0..l)
Bᵢ(τ)                           # (i in 0..l)
Lᵢ(τ) / γ                       # (i in 0..l)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in 0..l)
{% endhighlight %}


After the second eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in l+1..m)
Bᵢ(τ)                           # (i in l+1..m)
Lᵢ(τ) / γ                       # (i in l+1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in l+1..m)
{% endhighlight %}


then part of the verification key is

{% highlight rust %}
let vk = VerifyingKey::<E> {
    alpha_g1: g1.mul(alpha).into_affine(),
    beta_g1: g1.mul(beta).into_affine(),
    beta_g2: g2.mul(beta).into_affine(),
    gamma_g2: g2.mul(gamma).into_affine(),
    delta_g1: g1.mul(delta).into_affine(),
    delta_g2: g2.mul(delta).into_affine(),
    ic: ic.into_iter().map(|e| e.into_affine()).collect(),
};
{% endhighlight %}

a.k.a

{% highlight bash %}
# G1 elements
α, β, δ
Lᵢ(τ)/γ     # (i in 0..l), i.e. ic
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, γ, δ
{% endhighlight %}

the final stuff that is returned from the parameter setup, other than
verification key are:

{% highlight rust %}
pub struct Parameters<E: Engine> {
    pub vk: VerifyingKey<E>,

    // Elements of the form ((tau^i * t(tau)) / delta) for i between 0 and
    // m-2 inclusive. Never contains points at infinity.
    pub h: Arc<Vec<E::G1Affine>>,

    // Elements of the form (beta * u_i(tau) + alpha v_i(tau) + w_i(tau)) / delta
    // for all auxiliary inputs. Variables can never be unconstrained, so this
    // never contains points at infinity.
    pub l: Arc<Vec<E::G1Affine>>,

    // QAP "A" polynomials evaluated at tau in the Lagrange basis. Never contains
    // points at infinity: polynomials that evaluate to zero are omitted from
    // the CRS and the prover can deterministically skip their evaluation.
    pub a: Arc<Vec<E::G1Affine>>,

    // QAP "B" polynomials evaluated at tau in the Lagrange basis. Needed in
    // G1 and G2 for C/B queries, respectively. Never contains points at
    // infinity for the same reason as the "A" polynomials.
    pub b_g1: Arc<Vec<E::G1Affine>>,
    pub b_g2: Arc<Vec<E::G2Affine>>,
}
{% endhighlight %}

{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ             # i in 0..n-1, this is h
Lᵢ(τ)/γ                # (l in l+1..m), i.e. l
Aᵢ(τ)                  # (i in 1..m)
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}


## Prover
create_random_proof

create two random field **r** and **s**, the following is what we want
to prove:

totally we have m inputs (including public and aux)

{% highlight bash %}
# G1 elements
Aₚ = α + ∑ wᵢAᵢ(τ) + r*δ       # i in 0..m
   = α + A(τ) + r*δ
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bₚ = β + ∑ wᵢBᵢ(τ) + s*δ        # i in 0..m
   = β + B(τ) + s*δ
{% endhighlight %}

{% highlight bash %}
# G2 elements
L_aux = ∑ wᵢLᵢ(τ)      # i in l+1..m. This is the aux input
Cₚ = L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
{% endhighlight %}

# Verifier

What verifier needs to do is to prove is

{% highlight bash %}
L_input = ∑ wᵢLᵢ(τ)   # i in 0..l. This is the public input
Aₚ*Bₚ = α*β + (L_input/y)*y + Cₚ*δ    # i in 0...l
{% endhighlight %}

{% highlight bash %}
Aₚ*Bₚ
= (α + A(τ) + r*δ) * (β + B(τ) + s*δ)
= α*β + α*B(τ) + α*s*δ + β*A(τ) + A(τ)*B(τ) + s*δ*A(τ) + r*β*δ + r*δ*B(τ) + r*s*δ*δ
= A(τ)*B(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}

{% highlight bash %}
α*β + (L_input/y)*y + Cₚ*δ
# expand Cₚ = L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
= α*β + L_input + (L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ)*δ
= α*β + L_input + L_aux + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# L(τ) = L_input + L_aux
= α*β + L(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# expand Aₚ = α + A(τ) + r*δ
# expand Bₚ = β + B(τ) + s*δ
= α*β + L(τ) + H(τ)*T(τ) + s*δ*(α + A(τ) + r*δ) + r*δ*(β + B(τ) + s*δ) - r*s*δ*δ
= α*β + L(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
# expand L(τ) = α*B(τ) + β*A(τ) + C(τ)
= α*β + α*B(τ) + β*A(τ) + C(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
= C(τ) + H(τ)*T(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}


