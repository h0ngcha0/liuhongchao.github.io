---
layout: post
category: Zero Knowledge Proofs, Blockchain, ZCash
title: zk-SNARKs Explained with Bellman
---

### Trusted setup
Generate random field element **alpha** (α), **beta** (β), **gamma** (γ), **delta** (δ) and **tau** (τ).

We need to have two paring friendly curve, **G1** and **G2**, and pick two random points on each curve,
**g1** and **g2**.

A computation with **m** variables, of which **l** as public, **n** constraints
{% highlight bash %}
T(x) = (x-1)(x-2)(x-3)....(x-n-1)  # target polynomial
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
{% endhighlight %}

For prover, we need to have the following elements

{% highlight bash %}
# G1 elements
α, δ, 1,
τⁱ          # (i in 0..n-1)
Lᵢ(τ)/δ     # (i in l+1..m)
τⁱT(τ)/δ    # (i in 1..n-2)
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, δ, 1,
τⁱ          # (i in 0..n-1),
{% endhighlight %}

For the verifier, we need the following elements

{% highlight bash %}
# G1 elements
1,
Lᵢ(τ)/γ     # (i in 0..l),
{% endhighlight %}

{% highlight bash %}
# G2 elements
1, γ, δ
{% endhighlight %}

{% highlight bash %}
# Precomputed Gt element, in the paring domain
α₁ * β₂
{% endhighlight %}


[insert generator.rs:19]

| alpha | xxx |
| beta  | xxx |


the way to represent a R1CS

{% highlight rust %}
let mut assembly = KeypairAssembly {
    num_inputs: 0,
    num_aux: 0,
    num_constraints: 0,
    at_inputs: vec![],
    bt_inputs: vec![],
    ct_inputs: vec![],
    at_aux: vec![],
    bt_aux: vec![],
    ct_aux: vec![],
};
{% endhighlight %}

for each of the variables (element in FF), when we alloc_input or
alloc, we push an empty vector into `at_inputs`, `bt_inputs` and
`ct_inputs` or `at_aux`, `bt_aux` and `ct_aux`.

each of these empty vectors will be used to store constraints specific
for a variable, in the format of (coefficient, numOfConstrant).

this is how the R1CS is represented.


To recap, this is the original program we are trying to prove.

{% highlight c %}
// Flattened into quadratic equations
// (x^3 + x + 5 == 35):
x * x = tmp_1
tmp_1 * x = y
y + x + 5= out
{% endhighlight %}

after this point, R1CS is represetned in KeypairAssembly.

Now lets talk about powers_of_tau. If i understand correctly,
powers_of_tau should be τⁱ, i from 1 ~ number of constrants

first it is initiated to 5 zeros (we have 5 constraints here).

basically (2 ^ exp) number of constraints is the minimal number of
constraints that is in the form of 2ⁿ but bigger than the number of
constraints

in our case m = 2³, exp = 3, and the number of constraints are 5 (<2³)

and omega (ω) calculated as follows

{% highlight rust %}
// Compute omega, the 2^exp primitive root of unity
let mut omega = E::Fr::root_of_unity();
for _ in exp..E::Fr::S {
    omega.square();
}
{% endhighlight %}

omega = (g^t)^(2^(s - exp)), since root_of_unity as mentioned above is g^t.

omega = (g^t)^(2^s/2^exp)
      = (g^t)^(2^s) * (g^t)(1/(2^exp))
      = 1 * (g^t)(1/(2^exp))
      = (g^t)(1/(2^exp))

so basically: omege^(2^exp) = g^t = root_of_unity

then it calculates wnaf, which is a way to do perform exponantiation
on g in an efficient way

g1_wnaf.scalar(n) will calculate g1ⁿ in an efficient way.

same with g2_wnaf

then it calculates gamma_inverse (1/γ) and delta_inverse
(1/δ). because 1/δ is needed by the prover, and 1/γ is needed by the
verifier, as seen in the table above.

then we start to actually calculate the actual power of tau!!!!
and also T(x)

after line 244, power_of_tau should contain τⁱ (i in 1..2ᵐ where m is
2^exp)


then it calculates T(τ)/δ, which is needed as part of the proving key,
this is through coeff. perhaps the reason to call it a coeff is
because it is the coeff of τⁱT(τ)/δ. This is line generator.rs:245

from line generator.rs:249, it calculates H query, which is basically
{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ  # i in 0..n-1
{% endhighlight %}


Ok, now at generator.rs:275, now it is the interesting bit, why do we
need to do iFFT? what the result would be?
my guess is that it converts τⁱ to some kind of lagrange coefficients
which can be used later.

After line 278, it becomes a vector of points, with length 8, which is
2³. Fine.

At line 278, we are trying to get more variables.

variables: a, b_g1, b_g2, ic, l, looks like this is for setting
variables, since the length matches.

line 284, eval function, the purpose of this function is to evaluate
for normal input and aux input.

right now at_inputs, bt_inputs, and ct_inputs, are all in the lagrange
form, and also the power_of_tau is in lagrange form as well.

basically we are doing this. if variable polynomial x has (3, 2), (4,
7)  in an 8 steps constraints, 3 and 4 being coefficient, and 1, and 2
being the 2nd and 7th operation, then we basically do

3*(power_of_tau[2]) + 4*(power_of_tau[7])

and this is then the evaluation of a variable polynomial.

after this, it basically gives you this:

After the first eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in 0..l)
Bᵢ(τ)                           # (i in 0..l)
Lᵢ(τ) / γ                       # (i in 0..l)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in 0..l)
{% endhighlight %}


After the second eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in l+1..m)
Bᵢ(τ)                           # (i in l+1..m)
Lᵢ(τ) / γ                       # (i in l+1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in l+1..m)
{% endhighlight %}


then part of the verification key is

{% highlight rust %}
let vk = VerifyingKey::<E> {
    alpha_g1: g1.mul(alpha).into_affine(),
    beta_g1: g1.mul(beta).into_affine(),
    beta_g2: g2.mul(beta).into_affine(),
    gamma_g2: g2.mul(gamma).into_affine(),
    delta_g1: g1.mul(delta).into_affine(),
    delta_g2: g2.mul(delta).into_affine(),
    ic: ic.into_iter().map(|e| e.into_affine()).collect(),
};
{% endhighlight %}

a.k.a

{% highlight bash %}
# G1 elements
α, β, δ
Lᵢ(τ)/γ     # (i in 0..l), i.e. ic
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, γ, δ
{% endhighlight %}

the final stuff that is returned from the parameter setup, other than
verification key are:

{% highlight rust %}
pub struct Parameters<E: Engine> {
    pub vk: VerifyingKey<E>,

    // Elements of the form ((tau^i * t(tau)) / delta) for i between 0 and
    // m-2 inclusive. Never contains points at infinity.
    pub h: Arc<Vec<E::G1Affine>>,

    // Elements of the form (beta * u_i(tau) + alpha v_i(tau) + w_i(tau)) / delta
    // for all auxiliary inputs. Variables can never be unconstrained, so this
    // never contains points at infinity.
    pub l: Arc<Vec<E::G1Affine>>,

    // QAP "A" polynomials evaluated at tau in the Lagrange basis. Never contains
    // points at infinity: polynomials that evaluate to zero are omitted from
    // the CRS and the prover can deterministically skip their evaluation.
    pub a: Arc<Vec<E::G1Affine>>,

    // QAP "B" polynomials evaluated at tau in the Lagrange basis. Needed in
    // G1 and G2 for C/B queries, respectively. Never contains points at
    // infinity for the same reason as the "A" polynomials.
    pub b_g1: Arc<Vec<E::G1Affine>>,
    pub b_g2: Arc<Vec<E::G2Affine>>,
}
{% endhighlight %}

{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ             # i in 0..n-1, this is h
Lᵢ(τ)/γ                # (l in l+1..m), i.e. l
Aᵢ(τ)                  # (i in 1..m)
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}


### Prover
create_random_proof
([prover.rs:162](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L162))


create two random field **r** and **s**, the following is what we want
to prove:

totally we have m inputs (including public and aux)

ProvingAssignment is also a ConstraintSystem.

{% highlight rust %}
struct ProvingAssignment<E: Engine> {
    // Density of queries
    a_aux_density: DensityTracker,
    b_input_density: DensityTracker,
    b_aux_density: DensityTracker,

    // Evaluations of A, B, C polynomials
    a: Vec<Scalar<E>>,
    b: Vec<Scalar<E>>,
    c: Vec<Scalar<E>>,

    // Assignments of variables
    input_assignment: Vec<E::Fr>,
    aux_assignment: Vec<E::Fr>,
}
{% endhighlight %}

How are the values represented in ProvingAssignment?

alloc and alloc_input will basically push variables (value assigned
into aux_assignment or input_assignment). density not sure what that
is useful, perhaps just for optimization.

enforce, basically evaluates each of the operation, use the actual
value of the variable. 

in the end, a, b, c will contain the result of each operation at a, b, c
position evaluated at with the value of those variables.

lets talk about h, this is a way to calculate (A(x) * B(x) / T(x))

this h prover:211, is to
1) calculate H(x) by (A(x) * B(x) - C(x)/ T(x))
2) multiply H(x) by (τⁱT(τ)/δ), since this is part of Cₚ

basically this part H(τ)*(Z(τ)/δ)1

and then what is next?


then it calculates the following things:
1. Aₚ

{% highlight bash %}
# G1 elements
Aₚ = α + ∑ wᵢAᵢ(τ) + r*δ       # i in 0..m
   = α + A(τ) + r*δ
{% endhighlight %}

In bellman, the implementation can be found in
[prover.rs:304](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L304),
roughly this is what it does:

{% highlight rust %}
// Aₚ = r*δ
let mut g_a = vk.delta_g1 * &r;
// Aₚ = α + r*δ 
AddAssign::<&E::G1Affine>::add_assign(&mut g_a, &vk.alpha_g1);
// Aₚ = α + A(τ) + r*δ 
AddAssign::<&E::G1>::add_assign(&mut g_a, &a_answer);
{% endhighlight %}

2. Bₚ

{% highlight bash %}
# G2 elements
Bₚ = β + ∑ wᵢBᵢ(τ) + s*δ        # i in 0..m
   = β + B(τ) + s*δ
{% endhighlight %}

In bellman, the implementation can be found in
[prover.rs:306](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L306),
roughly this is what it does:

{% highlight rust %}
// Bₚ = s*δ
let mut g_b = vk.delta_g2 * &s;
// Bₚ = β + s*δ
AddAssign::<&E::G2Affine>::add_assign(&mut g_b, &vk.beta_g2);
// Bₚ = β + B(τ) + s*δ
AddAssign::<&E::G2>::add_assign(&mut g_b, &b2_answer);
{% endhighlight %}

3. Cₚ

{% highlight bash %}
# G2 elements
L_aux(τ) = ∑ wᵢLᵢ(τ)  # i in l+1..m. This is the aux input
Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
   # Expand Aₚ and Bₚ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*(α + A(τ) + r*δ) + r*(β + B(τ) + s*δ) - r*s*δ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*α + s*A(τ) + r*β + r*B(τ) + r*s*δ
{% endhighlight %}

In bellman, the implementation can be found in
[prover.rs:308](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L308),
roughly this is what it does:

{% highlight rust %}
let mut g_c;
{
    let mut rs = r;
    rs.mul_assign(&s);

    // Cₚ = r*s*δ
    g_c = vk.delta_g1.mul(rs);

    // Cₚ = r*s*δ + s*α
    g_c.add_assign(&vk.alpha_g1.mul(s));

    // Cₚ = r*s*δ + s*α + r*β
    g_c.add_assign(&vk.beta_g1.mul(r));
}

// Cₚ = s*A(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut a_answer, s);
g_c.add_assign(&a_answer);

// Cₚ = s*A(τ) + r*B(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut b1_answer, r);
g_c.add_assign(&b1_answer);

// Cₚ = H(τ)*(T(τ)/δ) + s*A(τ) + r*B(τ) + r*s*δ + s*α + r*β
g_c.add_assign(&h.wait()?);

// Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*A(τ) + r*B(τ) + r*s*δ + s*α + r*β
g_c.add_assign(&l.wait()?);
{% endhighlight %}

Finally, the proof is basically a bundle of Aₚ, Bₚ and Cₚ
([prover.rs:334](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L334))


{% highlight rust %}
Ok(Proof {
    a: g_a.to_affine(),
    b: g_b.to_affine(),
    c: g_c.to_affine(),
})
{% endhighlight %}

## Verifier

### Theory

The goal of the verifier is to take the proof, i.e. Aₚ, Bₚ and Cₚ, and
verify that the following equation holds:

{% highlight bash %}
# L_input(τ) = ∑ wᵢLᵢ(τ), i in 0..l
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
{% endhighlight %}

`L_input` is the public input.

To see what exactly what it means if this equation holds, we can try
to expand on the left hand side (LHS) and the right hand side (RHS) of
the equation.

#### LHS

`Aₚ*Bₚ` is equivalent to `A(τ)*B(τ) + REM` as shown below.

{% highlight bash %}
Aₚ*Bₚ
= A(τ)*B(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= A(τ)*B(τ) + REM
{% endhighlight %}

<details>
  <summary>Click here to see a more detailed deduction</summary>
{% highlight bash %}
Aₚ*Bₚ
# Expand Aₚ = (α + A(τ) + r*δ)
# Expand Bₚ = (β + B(τ) + s*δ)
= (α + A(τ) + r*δ) * (β + B(τ) + s*δ)
= α*β + α*B(τ) + α*s*δ + β*A(τ) + A(τ)*B(τ) + s*δ*A(τ) + r*β*δ + r*δ*B(τ) + r*s*δ*δ
= A(τ)*B(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= A(τ)*B(τ) + REM
{% endhighlight %}
</details>

#### RHS

`α*β + (L_input/γ)*γ + Cₚ*δ` is equivalent to `C(τ) + H(τ)*T(τ) + REM`
as shown below.

{% highlight bash %}
α*β + (L_input/y)*y + Cₚ*δ
= C(τ) + H(τ)*T(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= C(τ) + H(τ)*T(τ) + REM
{% endhighlight %}

<details>
  <summary>Click to see a more detailed deduction</summary>
{% highlight bash %}
α*β + (L_input/γ)*γ + Cₚ*δ
# expand Cₚ = L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
= α*β + L_input(τ) + (L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ)*δ
= α*β + L_input(τ) + L_aux(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# L(τ) = L_input(τ) + L_aux(τ)
= α*β + L(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# expand Aₚ = α + A(τ) + r*δ
# expand Bₚ = β + B(τ) + s*δ
= α*β + L(τ) + H(τ)*T(τ) + s*δ*(α + A(τ) + r*δ) + r*δ*(β + B(τ) + s*δ) - r*s*δ*δ
= α*β + L(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
# expand L(τ) = α*B(τ) + β*A(τ) + C(τ)
= α*β + α*B(τ) + β*A(τ) + C(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
= C(τ) + H(τ)*T(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= C(τ) + H(τ)*T(τ) + REM
{% endhighlight %}
</details>

What this means is that if we can prove `LHS = RHS`, then we have also
proved that `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` as shown below.

{% highlight bash %}
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
# Use the LHS and RHS deduction
A(τ)*B(τ) + REM = C(τ) + H(τ)*T(τ) + REM

# Hooray! This is what we want to prove!
A(τ)*B(τ) - C(τ) = H(τ)*T(τ)
{% endhighlight %}

Once `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` is proved to be true, the verifier
is confident that the program is executed faithfully with the correct
aux input.

### Implementation
The verification code in Bellman is located at
[verifier.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L21). As
explained by the comments, the original equation
`Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ` is converted to
`Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β`, which only requires one
final exponentiation ([verifier.rs:44](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L44)).

{% highlight rust %}
// Code that proves:
// Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β

Ok(E::final_exponentiation(&E::miller_loop(
    [
        // Aₚ*Bₚ
        (&proof.a.prepare(), &proof.b.prepare()),
        // (L_input(τ)/γ)*(-γ)
        (&acc.into_affine().prepare(), &pvk.neg_gamma_g2),
        // Cₚ*(-δ)
        (&proof.c.prepare(), &pvk.neg_delta_g2),
    ]
    .iter(),
))
.unwrap()
    // α*β
    == pvk.alpha_g1_beta_g2)
{% endhighlight %}
