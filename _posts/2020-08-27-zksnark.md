---
layout: post
category: Zero Knowledge Proofs, Blockchain, ZCash, Groth16, Bellman, ZKP, zk-SNARKs, snarks
title: zk-SNARKs Explained with Bellman
---

[Zero knowledge
proofs](https://en.wikipedia.org/wiki/Zero-knowledge_proof) (ZKP) is
one of the the most exciting cryptographic inventions after
[Public-key
cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography). zk-SNARK
is a specific type of ZKP which allows one party (the prover) to
convince third parties (the verifiers) that the prover faithfully
executed a program with some secret information, without conveying any
knowledge about the secret information itself. zk-SNARK also generates
succinct (hundreds of bytes) proofs that can be verified with constant
time even though the original computation might be much larger, which
means that other than the obvious privacy benefits, zk-SNARK can also
be used to trustlessly outsource expensive computation.

To apply zk-SNARK, a computation needs to be expressed in terms of
algebraic circuit, converted to a constraint system called
R1CS, and then finally converted to a form called "quadratic arithmetic
program" (QAP). The intuition of going through this complex
transformation is that
1. A computation can be viewed as series of constraints from the
   inputs to the outputs, but just expressing a computation in terms
   of constraints doesn't make the computation more "succinct" or
   easier to apply cryptographic algorithms.
2. QAP in a way "compresses" those constraints into one using
   polynomials, which makes it efficient to verify and also easier to
   apply cryptographic protocols such as
   [Pinocchio](https://eprint.iacr.org/2013/279.pdf) or
   [Groth16](https://eprint.iacr.org/2016/260.pdf) to achieve
   soundness, completeness and zero-knowledgeness.

<img src="{{ site.baseurl }}/images/zksnark-steps.png" alt="zksnark steps" style="width: 220px;"/><br/>
<span class="image-label">Steps of transformation for zk-SNARK, drawn by Eran Tromer</span>

For more detailed explanations of the QAP transformation, please take a look at
[Why and How zk-SNARK works](https://arxiv.org/abs/1906.07221) by
Maksym Petkus or [Quadratic Arithmetic Programs: from Zero to
Hero](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649)
by Vitalik Buterin. To use an example in Vitalik's article, a simple
program `x³ + x + 5 == 35` can be converted into the following QAP.

<img src="{{ site.baseurl }}/images/qap.png" alt="QAP" style="width: 400px;"/><br/>
<span class="image-label">QAP for x³ + x + 5 == 35, as in Vitalik's [Quadratic Arithmetic Programs: from Zero to
Hero](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649)</span>

This article assumes that the readers understand the process of QAP
transformation, specifically why proving `A(τ)*B(τ)-C(τ) = H(τ)*Z(τ)`
is important in terms of completenss and soundness. It also assumes
some high level understanding of the [elliptic curve
paring](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627). With
that, this article tries to explain how zk-SNARK works by walking
through how it is implemented in
[Bellman](https://github.com/zkcrypto/bellman) (0.7.0), a rust library
which is used by the first widespread zk-SNARK application
[ZCash](https://z.cash/). Bellman currently implements the
[Groth16](https://eprint.iacr.org/2016/260.pdf) proving system, which
can be roughly divided into three parts: **Trusted setup**, **Prover**
and **Verifier**. This article discusses each part in details.

## Trusted setup

Trusted setup is a process to set up what's called "Common Reference
String" (CRS) between provers and verifiers. CRS are basically
encrypted secret information that facilitates the cryptographic
protocols (e.g. Groth16) between provers and verifiers in
zk-SNARK. The secret information itself (a.k.a toxic waste) can not be
known to the prover, otherwise the entire proof system breaks down.

Let's say a computation has `m` variables, `l` of which are
public. Take `x³ + x + 5 = 35` as example again where the prover wants
to prove that (s)he knows the secret solution (3) without revealing
it. This program can be broken up into the following 3 constraints
in the form of `A * B = C`:

{% highlight bash %}
x * x = x_squared
x_squared * x = x_cubed
(x_cubed + x + 5) * 1 = out
{% endhighlight %}

There are 4 variables in total (i.e. `x`, `x_squared`, `x_cubed` and
`out`), among which `out` has a publicly known value 35. Therefore `m`
should be 4, and `l` should be 1.

Another important parameter is the number of constraints `n`. The
value of `n` for `x³ + x + 5 = 35` should be 3 as shown above. This
number dictates the target polynomial `Z(x)`:

{% highlight bash %}
# Target polynomial
Z(x) = (x-1)(x-2)(x-3)....(x-n)
{% endhighlight %}

Assuming that the program is converted to the QAP form, which really
means that we know variable polynomials `Aᵢ(x)`, `Bᵢ(x)` and
`Cᵢ(x)`. For the prover, if he knows the value of all variables `wᵢ`
(including the secret ones), then ultimately (s)he wants to prove the
following statement in a way that reveals nothing about the secrets:

{% highlight haskell %}
A(x) * B(x) - C(x) = H(x) * Z(x)
  where
    A(x) = ∑ wᵢAᵢ(x)  -- i in 1..m
    B(x) = ∑ wᵢBᵢ(x)  -- i in 1..m
    C(x) = ∑ wᵢCᵢ(x)  -- i in 1..m
{% endhighlight %}

Groth16 protocol is one such way to achieve that. It requires two
paring friendly curves: `G1`, `G2` (with the paring domain
`GT`). During the trusted setup, the first thing it does is to select
one random point on each curve: `g1` and `g2`.

Next, it generates the following 5 random field elements: `α` (alpha),
`β` (beta), `γ` (gamma), `δ` (delta) and `τ` (tau). With `α` and `β`,
it also defines the polynomial `Lᵢ(x)`:

{% highlight bash %}
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
{% endhighlight %}

With all the information created so far, Groth16 generates the
following `G1` and `G2` points (values encrypted using `g1` or
`g2`) for the prover:

{% highlight bash %}
# G1 elements
α, δ, 1,
τⁱ          # (i in 0..n-1)
Lᵢ(τ)/δ     # (i in l+1..m)
τⁱZ(τ)/δ    # (i in 1..n-2)

# G2 elements
β, δ, 1,
τⁱ          # (i in 0..n-1),
{% endhighlight %}

For the verifier, the following points on `G1` and `G2` and `GT` are
created during the trusted setup:

{% highlight bash %}
# G1 elements
1,
Lᵢ(τ)/γ     # (i in 1..l),

# G2 elements
1, γ, δ

# Gt elements (α in G1, β in G2)
α₁ * β₂
{% endhighlight %}

After all these information is created, it is mandatory that random
field elements `α`, `β`, `γ`, `δ` and `τ` (a.k.a toxic waste) are
destroyed. In the **Prover** and **Verifier** section, we will discuss
how these information is used by both the prover and verifier so that
the prover can convinces the verifier that the `A(x) * B(x) - C(x) = H(x) *
Z(x)` equation holds. For now let's take a look at how trusted setup
is implemented in Bellman.

### Implementation

The code that implements trusted setup in bellman is located at
[generator.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs),
specifically the
[generate_random_parameters](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L19)
function. The code that
[generates](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L30)
`g1`, `g2`, `α`, `β`, `γ`, `δ` and `τ` is pretty straightforward.

{% highlight rust %}
let g1 = E::G1::random(rng);
let g2 = E::G2::random(rng);
let alpha = E::Fr::random(rng);
let beta = E::Fr::random(rng);
let gamma = E::Fr::random(rng);
let delta = E::Fr::random(rng);
let tau = E::Fr::random(rng);
{% endhighlight %}

In bellman, computation is expressed in "circuits" using the
[Circuit](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/lib.rs#L159)
and
[ConstraintSystem](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/lib.rs#L383)
abstraction. For `x³ + x + 5 = 35` which has the following
constraints:

{% highlight bash %}
x * x = x_squared
x_squared * x = x_cubed
(x_cubed + x + 5) * 1 = out
{% endhighlight %}

The 2nd constraint, for example, can be written in bellman like this:

{% highlight rust %}
// Allocate: x_squared * x = x_cubed
let x_cubed_val = x_squared_val.map(|mut e| {
    e.mul_assign(&x_val.unwrap());
    e
});
let x_cubed = cs.alloc(|| "x_cubed", || {
    x_cubed_val.ok_or(SynthesisError::AssignmentMissing)
})?;
// Enforce: x_squared * x = x_cubed
cs.enforce(
    || "x_cubed",
    |lc| lc + x_squared,
    |lc| lc + x,
    |lc| lc + x_cubed
);
{% endhighlight %}
<summary>A complete representation of x³ + x + 5 = 35 in bellman can
be found <a href="https://github.com/liuhongchao/bellman-examples/blob/master/src/cube.rs#L45">here</a></summary>

`cs` in the example above is an instance of a
[ConstraintSystem](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/lib.rs#L383). During
the trusted setup, circuits are converted to QAP using the
[KeypairAssembly](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L43)
ConstraintSystem.

{% highlight rust %}
/// This is our assembly structure that we'll use to synthesize the
/// circuit into a QAP.
struct KeypairAssembly<Scalar: PrimeField> {
    num_inputs: usize,
    num_aux: usize,
    num_constraints: usize,
    at_inputs: Vec<Vec<(Scalar, usize)>>,
    bt_inputs: Vec<Vec<(Scalar, usize)>>,
    ct_inputs: Vec<Vec<(Scalar, usize)>>,
    at_aux: Vec<Vec<(Scalar, usize)>>,
    bt_aux: Vec<Vec<(Scalar, usize)>>,
    ct_aux: Vec<Vec<(Scalar, usize)>>,
}
{% endhighlight %}


When
[alloc_input](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L77)
or
[alloc](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L58)
is called to allocate a variable, an empty vector is pushed to
`at_inputs`, `bt_inputs`, `ct_inputs` or `at_aux`, `at_aux`, `at_aux`
respectively. The index of the empty vector is used to keep track of
the newly allocated variables.

These empty vectors is used to store a sequence of `(coefficient,
constraint_number)` tuple for each variable, basically recording
when and how a particular variable is used in the
circuit. [enforce](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L96)
function ensures that this sequence of tuple is stored correctly for
all variables.

After KeypairAssembly
[synthesize](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/generator.rs#L190)
the circuit (basically executes all the `alloc`, `alloc_input` and
`enforce` in it), what we end up with is essentially the lagrange
representation of all the variable polynomials stored in `at_inputs`,
`bt_inputs`, `ct_inputs` or `at_aux`, `at_aux`, `at_aux`. We now have
`Aᵢ(x)`, `Bᵢ(x)` and `Cᵢ(x)`.

———

Now lets talk about powers_of_tau. If i understand correctly,
powers_of_tau should be τⁱ, i from 1 ~ number of constrants

first it is initiated to 5 zeros (we have 5 constraints here).

basically (2 ^ exp) number of constraints is the minimal number of
constraints that is in the form of 2ⁿ but bigger than the number of
constraints

in our case m = 2³, exp = 3, and the number of constraints are 5 (<2³)

and omega (ω) calculated as follows

{% highlight rust %}
// Compute omega, the 2^exp primitive root of unity
let mut omega = E::Fr::root_of_unity();
for _ in exp..E::Fr::S {
    omega.square();
}
{% endhighlight %}

omega = (g^t)^(2^(s - exp)), since root_of_unity as mentioned above is g^t.

omega = (g^t)^(2^s/2^exp)
      = (g^t)^(2^s) * (g^t)(1/(2^exp))
      = 1 * (g^t)(1/(2^exp))
      = (g^t)(1/(2^exp))

so basically: omege^(2^exp) = g^t = root_of_unity

then it calculates wnaf, which is a way to do perform exponantiation
on g in an efficient way

g1_wnaf.scalar(n) will calculate g1ⁿ in an efficient way.

same with g2_wnaf

then it calculates gamma_inverse (1/γ) and delta_inverse
(1/δ). because 1/δ is needed by the prover, and 1/γ is needed by the
verifier, as seen in the table above.

then we start to actually calculate the actual power of tau!!!!
and also T(x)

after line 244, power_of_tau should contain τⁱ (i in 1..2ᵐ where m is
2^exp)


then it calculates T(τ)/δ, which is needed as part of the proving key,
this is through coeff. perhaps the reason to call it a coeff is
because it is the coeff of τⁱT(τ)/δ. This is line generator.rs:245

from line generator.rs:249, it calculates H query, which is basically
{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ  # i in 0..n-1
{% endhighlight %}


Ok, now at generator.rs:275, now it is the interesting bit, why do we
need to do iFFT? what the result would be?
my guess is that it converts τⁱ to some kind of lagrange coefficients
which can be used later.

After line 278, it becomes a vector of points, with length 8, which is
2³. Fine.

At line 278, we are trying to get more variables.

variables: a, b_g1, b_g2, ic, l, looks like this is for setting
variables, since the length matches.

line 284, eval function, the purpose of this function is to evaluate
for normal input and aux input.

right now at_inputs, bt_inputs, and ct_inputs, are all in the lagrange
form, and also the power_of_tau is in lagrange form as well.

basically we are doing this. if variable polynomial x has (3, 2), (4,
7)  in an 8 steps constraints, 3 and 4 being coefficient, and 1, and 2
being the 2nd and 7th operation, then we basically do

3*(power_of_tau[2]) + 4*(power_of_tau[7])

and this is then the evaluation of a variable polynomial.

after this, it basically gives you this:

After the first eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in 0..l)
Bᵢ(τ)                           # (i in 0..l)
Lᵢ(τ) / γ                       # (i in 0..l)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in 0..l)
{% endhighlight %}


After the second eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in l+1..m)
Bᵢ(τ)                           # (i in l+1..m)
Lᵢ(τ) / γ                       # (i in l+1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in l+1..m)
{% endhighlight %}


then part of the verification key is

{% highlight rust %}
let vk = VerifyingKey::<E> {
    alpha_g1: g1.mul(alpha).into_affine(),
    beta_g1: g1.mul(beta).into_affine(),
    beta_g2: g2.mul(beta).into_affine(),
    gamma_g2: g2.mul(gamma).into_affine(),
    delta_g1: g1.mul(delta).into_affine(),
    delta_g2: g2.mul(delta).into_affine(),
    ic: ic.into_iter().map(|e| e.into_affine()).collect(),
};
{% endhighlight %}

a.k.a

{% highlight bash %}
# G1 elements
α, β, δ
Lᵢ(τ)/γ     # (i in 0..l), i.e. ic
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, γ, δ
{% endhighlight %}

the final stuff that is returned from the parameter setup, other than
verification key are:

{% highlight rust %}
pub struct Parameters<E: Engine> {
    pub vk: VerifyingKey<E>,

    // Elements of the form ((tau^i * t(tau)) / delta) for i between 0 and
    // m-2 inclusive. Never contains points at infinity.
    pub h: Arc<Vec<E::G1Affine>>,

    // Elements of the form (beta * u_i(tau) + alpha v_i(tau) + w_i(tau)) / delta
    // for all auxiliary inputs. Variables can never be unconstrained, so this
    // never contains points at infinity.
    pub l: Arc<Vec<E::G1Affine>>,

    // QAP "A" polynomials evaluated at tau in the Lagrange basis. Never contains
    // points at infinity: polynomials that evaluate to zero are omitted from
    // the CRS and the prover can deterministically skip their evaluation.
    pub a: Arc<Vec<E::G1Affine>>,

    // QAP "B" polynomials evaluated at tau in the Lagrange basis. Needed in
    // G1 and G2 for C/B queries, respectively. Never contains points at
    // infinity for the same reason as the "A" polynomials.
    pub b_g1: Arc<Vec<E::G1Affine>>,
    pub b_g2: Arc<Vec<E::G2Affine>>,
}
{% endhighlight %}

{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ             # i in 0..n-1, this is h
Lᵢ(τ)/γ                # (l in l+1..m), i.e. l
Aᵢ(τ)                  # (i in 1..m)
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

talk about why we wanna verify this: `A(τ)*B(τ) - C(τ) = H(τ)*T(τ)`


## Prover

The prover knows the value of all variables (`m` in total) involved in
in the computation, both public input variables (`l` in total) and
secret auxiliary variables (`m-l` in total). These variables are
represented by `wᵢ`. `wᵢ` represents input variables when `i` is
between `0` to `l`, and represents auxiliary variable when `i` is
between `l+1` to `m`.  With this knowledge, the prover wants to
construct three values: Aₚ, Bₚ and Cₚ, as defined below:

{% highlight haskell %}
-- G1 elements
Aₚ = α + A(τ) + r*δ
   where
     A(τ) = ∑ wᵢAᵢ(τ)  -- i in 0..m

-- G2 elements
Bₚ = β + B(τ) + s*δ
   where
     B(τ) = ∑ wᵢBᵢ(τ)  -- i in 0..m

-- G2 elements
Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
   where
     -- auxiliary input
     L_aux(τ) = ∑ wᵢLᵢ(τ)  -- i in l+1..m
{% endhighlight %}

`r` and `s` are randomly generated field elements by the prover.

With Aₚ, Bₚ and Cₚ, the verifier can somehow verify the final
statement `A(τ)*B(τ) - C(τ) = H(τ)*T(τ)` and therefore confirm that the
prover had executed the program faithfully without revealing the
auxiliary variables. We will break down how this is achieved later
when we discuss verifiers. For now, let's focus on how the prover
constructs Aₚ, Bₚ and Cₚ.

From the trusted setup, the prover knows the `G1` elements `α`, `δ` and
`G2` elements `β`, `δ`. The prover also knows the "program", which is
expressed as R1CS circuit and then converted to Quadratic Arithmetic
Program (QAP).

Concretely, the QAP program is expressed using `A`, `B` and `C` where

{% highlight haskell %}
A(x) = ∑ wᵢAᵢ(x)  -- i in 0..m
B(x) = ∑ wᵢBᵢ(x)  -- i in 0..m
C(x) = ∑ wᵢCᵢ(x)  -- i in 0..m
{% endhighlight %}

Also remember that `L` and `H` are defined in terms of `A`, `B`, `C`
and `T`, as follows

{% highlight haskell %}
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
H(x) = (A(x) * B(x) - C(x)) / T(x)
{% endhighlight %}

Knowing the value of all variables `wᵢ`, the prover has everything
needed to construct Aₚ, Bₚ and Cₚ.

### Implementation

The prover code in bellman is in located in
[prover.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs),
specifically
[create_proof](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L178)
function.

First of all, the program is captured (or "synthesized") using the
[ProvingAssignment](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L59)
data structure, which is also a type of
[ConstraintSystem](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/lib.rs#L383).

{% highlight rust %}
struct ProvingAssignment<E: Engine> {
    // Density of queries
    a_aux_density: DensityTracker,
    b_input_density: DensityTracker,
    b_aux_density: DensityTracker,

    // Evaluations of A, B, C polynomials
    a: Vec<Scalar<E>>,
    b: Vec<Scalar<E>>,
    c: Vec<Scalar<E>>,

    // Assignments of variables
    input_assignment: Vec<E::Fr>,
    aux_assignment: Vec<E::Fr>,
}
{% endhighlight %}

When
[alloc_input](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L91)
or
[alloc](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L78)
is called, the actual value of the variable is pushed to
`input_assignment` and `aux_assignment` vector respectively. Variables
are tracked by their position (index) in those vectors.

When
[enforce](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L103)
is called, it evaluates `A`, `B` and `C` for each operation (in the
form of `A*B=C`) with the variable values in `input_assignment`
and `aux_assignment`. The results are pushed to `a`, `b` and `c`
vectors respectively. After the entire circuit is
[synthesized](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L201),
`a`, `b` and `c` essentially becomes the lagrange representation of
`A(x)`, `B(x)` and `C(x)`.

Aₚ is relatively easy to create, it is equal to `α + A(τ) + r*δ`
([prover:304](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L304)):

{% highlight rust %}
// Aₚ = r*δ
let mut g_a = vk.delta_g1 * &r;
// Aₚ = α + r*δ
AddAssign::<&E::G1Affine>::add_assign(&mut g_a, &vk.alpha_g1);
let mut a_answer = a_inputs.wait()?;
AddAssign::<&E::G1>::add_assign(&mut a_answer, &a_aux.wait()?);
// Aₚ = α + A(τ) + r*δ
AddAssign::<&E::G1>::add_assign(&mut g_a, &a_answer);
{% endhighlight %}

Bₚ is computed in a [very similiar
way](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L306). What
is more interesting is Cₚ since it involves a more complex
`H(τ)*(T(τ)/δ)` expression. Recall that H(τ) is basically
`(A(t) * B(t) - C(t)) / T(t)` and `T(x)` is the target polynomial that
is public. Here is how it gets
[computed](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L211)
(`h` in the code represents `H(τ)*(T(τ)/δ)`:

{% highlight rust %}
let h = {
    let mut a = EvaluationDomain::from_coeffs(prover.a)?;
    let mut b = EvaluationDomain::from_coeffs(prover.b)?;
    let mut c = EvaluationDomain::from_coeffs(prover.c)?;
    a.ifft(&worker);
    a.coset_fft(&worker);
    b.ifft(&worker);
    b.coset_fft(&worker);
    c.ifft(&worker);
    c.coset_fft(&worker);

    // A * B
    a.mul_assign(&worker, &b);
    drop(b);
    // A * B - C
    a.sub_assign(&worker, &c);
    drop(c);
    // (A * B - C) / T
    a.divide_by_z_on_coset(&worker);
    a.icoset_fft(&worker);
    let mut a = a.into_coeffs();
    let a_len = a.len() - 1;
    a.truncate(a_len);
    // TODO: parallelize if it's even helpful
    let a = Arc::new(a.into_iter().map(|s| s.0).collect::<Vec<_>>());

    // ((A * B - C) / T) * (T / δ)
    multiexp(&worker, params.get_h(a.len())?, FullDensity, a)
};
{% endhighlight %}

Now the prover knows H(τ)*(T(τ)/δ), it becomes clearer how Cₚ is
[computed](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L308):

{% highlight rust %}
let mut g_c;
{
    let mut rs = r;
    rs.mul_assign(&s);

    // Cₚ = r*s*δ
    g_c = vk.delta_g1 * &rs;

    // Cₚ = r*s*δ + s*α
    AddAssign::<&E::G1>::add_assign(&mut g_c, &(vk.alpha_g1 * &s));

    // Cₚ = r*s*δ + s*α + r*β
    AddAssign::<&E::G1>::add_assign(&mut g_c, &(vk.beta_g1 * &r));
}

// Cₚ = s*A(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut a_answer, s);
AddAssign::<&E::G1>::add_assign(&mut g_c, &a_answer);

// Cₚ = r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut b1_answer, r);
AddAssign::<&E::G1>::add_assign(&mut g_c, &b1_answer);

// Cₚ = H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
AddAssign::<&E::G1>::add_assign(&mut g_c, &h.wait()?);

// Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
AddAssign::<&E::G1>::add_assign(&mut g_c, &l.wait()?);
{% endhighlight %}

As we can see, Cₚ computed as
`L_aux(τ)/δ + H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β`,
which is actually equivalent to
`L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ`, as shown below:

{% highlight bash %}
# G2 elements
L_aux(τ) = ∑ wᵢLᵢ(τ)  # i in l+1..m. This is the aux input
Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
   # Expand Aₚ and Bₚ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*(α + A(τ) + r*δ) + r*(β + B(τ) + s*δ) - r*s*δ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*α + s*A(τ) + r*β + r*B(τ) + r*s*δ
{% endhighlight %}

At this point, Aₚ, Bₚ and Cₚ are computed and prover completes the
proof.

## Verifier

The goal of the verifier is to take the proof, i.e. Aₚ, Bₚ and Cₚ, and
verify that the following equation holds:

{% highlight haskell %}
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
  where
    L_input(τ) = ∑ wᵢLᵢ(τ) -- i in 0..l
{% endhighlight %}

`L_input` is the public input.

To see what exactly what it means if this equation holds, we can try
to expand on the left hand side (LHS) and the right hand side (RHS) of
the equation.

#### LHS

`Aₚ*Bₚ` is equivalent to `A(τ)*B(τ) + REM`:

{% highlight haskell %}
Aₚ*Bₚ = A(τ)*B(τ) + REM
  where
    REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}

<details>
  <summary>Click here to see a more detailed deduction</summary>
{% highlight bash %}
Aₚ*Bₚ
# Expand Aₚ = (α + A(τ) + r*δ)
# Expand Bₚ = (β + B(τ) + s*δ)
= (α + A(τ) + r*δ) * (β + B(τ) + s*δ)
= α*β + α*B(τ) + α*s*δ + β*A(τ) + A(τ)*B(τ) + s*δ*A(τ) + r*β*δ + r*δ*B(τ) + r*s*δ*δ
= A(τ)*B(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= A(τ)*B(τ) + REM
{% endhighlight %}
</details>

#### RHS

`α*β + (L_input/γ)*γ + Cₚ*δ` is equivalent to `C(τ) + H(τ)*T(τ) + REM`:

{% highlight haskell %}
α*β + (L_input/y)*y + Cₚ*δ = C(τ) + H(τ)*T(τ) + REM
  where
    REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}

<details>
  <summary>Click to see a more detailed deduction</summary>
{% highlight bash %}
α*β + (L_input/γ)*γ + Cₚ*δ
# expand Cₚ = L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
= α*β + L_input(τ) + (L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ)*δ
= α*β + L_input(τ) + L_aux(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# L(τ) = L_input(τ) + L_aux(τ)
= α*β + L(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# expand Aₚ = α + A(τ) + r*δ
# expand Bₚ = β + B(τ) + s*δ
= α*β + L(τ) + H(τ)*T(τ) + s*δ*(α + A(τ) + r*δ) + r*δ*(β + B(τ) + s*δ) - r*s*δ*δ
= α*β + L(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
# expand L(τ) = α*B(τ) + β*A(τ) + C(τ)
= α*β + α*B(τ) + β*A(τ) + C(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
= C(τ) + H(τ)*T(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= C(τ) + H(τ)*T(τ) + REM
{% endhighlight %}
</details>

What this means is that if we can prove `LHS = RHS`, then we have also
proved that `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` as shown below.

{% highlight bash %}
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
# Use the LHS and RHS deduction
A(τ)*B(τ) + REM = C(τ) + H(τ)*T(τ) + REM

# Hooray! This is what we want to prove!
A(τ)*B(τ) - C(τ) = H(τ)*T(τ)
{% endhighlight %}

Once `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` is proved to be true, the verifier
is confident that the program is executed faithfully with the correct
aux input.

### Implementation
The verification code in Bellman is located at
[verifier.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L21). As
explained by the comments, the original equation
`Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ` is converted to
`Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β`, which only requires one
final exponentiation ([verifier.rs:44](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L44)).

{% highlight rust %}
// Code that proves:
// Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β

Ok(E::final_exponentiation(&E::miller_loop(
    [
        // Aₚ*Bₚ
        (&proof.a.prepare(), &proof.b.prepare()),
        // (L_input(τ)/γ)*(-γ)
        (&acc.into_affine().prepare(), &pvk.neg_gamma_g2),
        // Cₚ*(-δ)
        (&proof.c.prepare(), &pvk.neg_delta_g2),
    ]
    .iter(),
))
.unwrap()
    // α*β
    == pvk.alpha_g1_beta_g2)
{% endhighlight %}

The `E::final_exponentiation` and `E::miller_loop` functions are two
steps needed to compute the [elliptic curve
paring](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627).
The paring of `α*β` (`pvk.alpha_g1_beta_g2`) is already pre-computed in
the setup phase.

## Summary

give some performance data

## References
