---
layout: post
category: Zero Knowledge Proofs, Blockchain, ZCash, Groth16, Bellman, ZKP, zk-SNARKs, snarks
title: zk-SNARKs Explained with Bellman
---

## Trusted setup
Generate random field element **alpha** (α), **beta** (β), **gamma** (γ), **delta** (δ) and **tau** (τ).

We need to have two paring friendly curve, **G1** and **G2**, and pick two random points on each curve,
**g1** and **g2**.

A computation with **m** variables, of which **l** as public, **n** constraints
{% highlight bash %}
T(x) = (x-1)(x-2)(x-3)....(x-n-1)  # target polynomial
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
{% endhighlight %}

For prover, we need to have the following elements

{% highlight bash %}
# G1 elements
α, δ, 1,
τⁱ          # (i in 0..n-1)
Lᵢ(τ)/δ     # (i in l+1..m)
τⁱT(τ)/δ    # (i in 1..n-2)
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, δ, 1,
τⁱ          # (i in 0..n-1),
{% endhighlight %}

For the verifier, we need the following elements

{% highlight bash %}
# G1 elements
1,
Lᵢ(τ)/γ     # (i in 0..l),
{% endhighlight %}

{% highlight bash %}
# G2 elements
1, γ, δ
{% endhighlight %}

{% highlight bash %}
# Precomputed Gt element, in the paring domain
α₁ * β₂
{% endhighlight %}


[insert generator.rs:19]

| alpha | xxx |
| beta  | xxx |


the way to represent a R1CS

{% highlight rust %}
let mut assembly = KeypairAssembly {
    num_inputs: 0,
    num_aux: 0,
    num_constraints: 0,
    at_inputs: vec![],
    bt_inputs: vec![],
    ct_inputs: vec![],
    at_aux: vec![],
    bt_aux: vec![],
    ct_aux: vec![],
};
{% endhighlight %}

for each of the variables (element in FF), when we alloc_input or
alloc, we push an empty vector into `at_inputs`, `bt_inputs` and
`ct_inputs` or `at_aux`, `bt_aux` and `ct_aux`.

each of these empty vectors will be used to store constraints specific
for a variable, in the format of (coefficient, numOfConstrant).

this is how the R1CS is represented.


To recap, this is the original program we are trying to prove.

{% highlight c %}
// Flattened into quadratic equations
// (x^3 + x + 5 == 35):
x * x = tmp_1
tmp_1 * x = y
y + x + 5= out
{% endhighlight %}

after this point, R1CS is represetned in KeypairAssembly.

Now lets talk about powers_of_tau. If i understand correctly,
powers_of_tau should be τⁱ, i from 1 ~ number of constrants

first it is initiated to 5 zeros (we have 5 constraints here).

basically (2 ^ exp) number of constraints is the minimal number of
constraints that is in the form of 2ⁿ but bigger than the number of
constraints

in our case m = 2³, exp = 3, and the number of constraints are 5 (<2³)

and omega (ω) calculated as follows

{% highlight rust %}
// Compute omega, the 2^exp primitive root of unity
let mut omega = E::Fr::root_of_unity();
for _ in exp..E::Fr::S {
    omega.square();
}
{% endhighlight %}

omega = (g^t)^(2^(s - exp)), since root_of_unity as mentioned above is g^t.

omega = (g^t)^(2^s/2^exp)
      = (g^t)^(2^s) * (g^t)(1/(2^exp))
      = 1 * (g^t)(1/(2^exp))
      = (g^t)(1/(2^exp))

so basically: omege^(2^exp) = g^t = root_of_unity

then it calculates wnaf, which is a way to do perform exponantiation
on g in an efficient way

g1_wnaf.scalar(n) will calculate g1ⁿ in an efficient way.

same with g2_wnaf

then it calculates gamma_inverse (1/γ) and delta_inverse
(1/δ). because 1/δ is needed by the prover, and 1/γ is needed by the
verifier, as seen in the table above.

then we start to actually calculate the actual power of tau!!!!
and also T(x)

after line 244, power_of_tau should contain τⁱ (i in 1..2ᵐ where m is
2^exp)


then it calculates T(τ)/δ, which is needed as part of the proving key,
this is through coeff. perhaps the reason to call it a coeff is
because it is the coeff of τⁱT(τ)/δ. This is line generator.rs:245

from line generator.rs:249, it calculates H query, which is basically
{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ  # i in 0..n-1
{% endhighlight %}


Ok, now at generator.rs:275, now it is the interesting bit, why do we
need to do iFFT? what the result would be?
my guess is that it converts τⁱ to some kind of lagrange coefficients
which can be used later.

After line 278, it becomes a vector of points, with length 8, which is
2³. Fine.

At line 278, we are trying to get more variables.

variables: a, b_g1, b_g2, ic, l, looks like this is for setting
variables, since the length matches.

line 284, eval function, the purpose of this function is to evaluate
for normal input and aux input.

right now at_inputs, bt_inputs, and ct_inputs, are all in the lagrange
form, and also the power_of_tau is in lagrange form as well.

basically we are doing this. if variable polynomial x has (3, 2), (4,
7)  in an 8 steps constraints, 3 and 4 being coefficient, and 1, and 2
being the 2nd and 7th operation, then we basically do

3*(power_of_tau[2]) + 4*(power_of_tau[7])

and this is then the evaluation of a variable polynomial.

after this, it basically gives you this:

After the first eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in 0..l)
Bᵢ(τ)                           # (i in 0..l)
Lᵢ(τ) / γ                       # (i in 0..l)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in 0..l)
{% endhighlight %}


After the second eval:

{% highlight bash %}
# G1 elements
Aᵢ(τ)                           # (i in l+1..m)
Bᵢ(τ)                           # (i in l+1..m)
Lᵢ(τ) / γ                       # (i in l+1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                           # (i in l+1..m)
{% endhighlight %}


then part of the verification key is

{% highlight rust %}
let vk = VerifyingKey::<E> {
    alpha_g1: g1.mul(alpha).into_affine(),
    beta_g1: g1.mul(beta).into_affine(),
    beta_g2: g2.mul(beta).into_affine(),
    gamma_g2: g2.mul(gamma).into_affine(),
    delta_g1: g1.mul(delta).into_affine(),
    delta_g2: g2.mul(delta).into_affine(),
    ic: ic.into_iter().map(|e| e.into_affine()).collect(),
};
{% endhighlight %}

a.k.a

{% highlight bash %}
# G1 elements
α, β, δ
Lᵢ(τ)/γ     # (i in 0..l), i.e. ic
{% endhighlight %}

{% highlight bash %}
# G2 elements
β, γ, δ
{% endhighlight %}

the final stuff that is returned from the parameter setup, other than
verification key are:

{% highlight rust %}
pub struct Parameters<E: Engine> {
    pub vk: VerifyingKey<E>,

    // Elements of the form ((tau^i * t(tau)) / delta) for i between 0 and
    // m-2 inclusive. Never contains points at infinity.
    pub h: Arc<Vec<E::G1Affine>>,

    // Elements of the form (beta * u_i(tau) + alpha v_i(tau) + w_i(tau)) / delta
    // for all auxiliary inputs. Variables can never be unconstrained, so this
    // never contains points at infinity.
    pub l: Arc<Vec<E::G1Affine>>,

    // QAP "A" polynomials evaluated at tau in the Lagrange basis. Never contains
    // points at infinity: polynomials that evaluate to zero are omitted from
    // the CRS and the prover can deterministically skip their evaluation.
    pub a: Arc<Vec<E::G1Affine>>,

    // QAP "B" polynomials evaluated at tau in the Lagrange basis. Needed in
    // G1 and G2 for C/B queries, respectively. Never contains points at
    // infinity for the same reason as the "A" polynomials.
    pub b_g1: Arc<Vec<E::G1Affine>>,
    pub b_g2: Arc<Vec<E::G2Affine>>,
}
{% endhighlight %}

{% highlight bash %}
# G1 elements
τⁱ*T(τ)/ δ             # i in 0..n-1, this is h
Lᵢ(τ)/γ                # (l in l+1..m), i.e. l
Aᵢ(τ)                  # (i in 1..m)
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

{% highlight bash %}
# G2 elements
Bᵢ(τ)                  # (i in 1..m)
{% endhighlight %}

talk about why we wanna verify this: `A(τ)*B(τ) - C(τ) = H(τ)*T(τ)`


## Prover

The prover knows the value of all variables (`m` in total) involved in
in the computation, both public input variables (`l` in total) and
secret auxiliary variables (`m-l` in total). These variables are
represented by `wᵢ`. `wᵢ` represents input variables when `i` is
between `0` to `l`, and represents auxiliary variable when `i` is
between `l+1` to `m`.  With this knowledge, the prover wants to
construct three values: Aₚ, Bₚ and Cₚ, as defined below:

{% highlight haskell %}
-- G1 elements
Aₚ = α + A(τ) + r*δ
   where
     A(τ) = ∑ wᵢAᵢ(τ)  -- i in 0..m

-- G2 elements
Bₚ = β + B(τ) + s*δ
   where
     B(τ) = ∑ wᵢBᵢ(τ)  -- i in 0..m

-- G2 elements
Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
   where
     -- auxiliary input
     L_aux(τ) = ∑ wᵢLᵢ(τ)  -- i in l+1..m
{% endhighlight %}

`r` and `s` are randomly generated field elements by the prover.

With Aₚ, Bₚ and Cₚ, the verifier can somehow verify the final
statement `A(τ)*B(τ) - C(τ) = H(τ)*T(τ)` and therefore confirm that the
prover had executed the program faithfully without revealing the
auxiliary variables. We will break down how this is achieved later
when we discuss verifiers. For now, let's focus on how the prover
constructs Aₚ, Bₚ and Cₚ.

From the trusted setup, the prover knows the `G1` elements `α`, `δ` and
`G2` elements `β`, `δ`. The prover also knows the "program", which is
expressed as R1CS circuit and then converted to Quadratic Arithmetic
Program (QAP).

Concretely, the QAP program is expressed using `A`, `B` and `C` where

{% highlight haskell %}
A(x) = ∑ wᵢAᵢ(x)  -- i in 0..m
B(x) = ∑ wᵢBᵢ(x)  -- i in 0..m
C(x) = ∑ wᵢCᵢ(x)  -- i in 0..m
{% endhighlight %}

Also remember that `L` and `H` are defined in terms of `A`, `B`, `C`
and `T`, as follows

{% highlight haskell %}
Lᵢ(x) = β * Aᵢ(x) + α * Bᵢ(x) + Cᵢ(x)
H(x) = (A(x) * B(x) - C(x)) / T(x)
{% endhighlight %}

Knowing the value of all variables `wᵢ`, the prover has everything
needed to construct Aₚ, Bₚ and Cₚ.

### Implementation

The prover code in bellman is in located at
[prover.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs),
specifically
[create_proof](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L178).

First of all, the program is captured (or "synthesized") using the
[ProvingAssignment](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L59)
data structure, which is also a type of
[ConstraintSystem](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/lib.rs#L383).

{% highlight rust %}
struct ProvingAssignment<E: Engine> {
    // Density of queries
    a_aux_density: DensityTracker,
    b_input_density: DensityTracker,
    b_aux_density: DensityTracker,

    // Evaluations of A, B, C polynomials
    a: Vec<Scalar<E>>,
    b: Vec<Scalar<E>>,
    c: Vec<Scalar<E>>,

    // Assignments of variables
    input_assignment: Vec<E::Fr>,
    aux_assignment: Vec<E::Fr>,
}
{% endhighlight %}

When
[alloc_input](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L91)
or
[alloc](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L78)
is called, the actual value of the variable is pushed to
`input_assignment` and `aux_assignment` vector respectively. Variables
are tracked by their position (index) in those vectors.

When
[enforce](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L103)
is called, it evaluates `A`, `B` and `C` for each operation (in the
form of `A*B=C`) with the variable values in `input_assignment`
and `aux_assignment`. The results are pushed to `a`, `b` and `c`
vectors respectively. After the entire circuit is
[synthesized](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L201),
`a`, `b` and `c` essentially becomes the lagrange representation of
`A(x)`, `B(x)` and `C(x)`.

Aₚ is relatively easy to create, it is equal to `α + A(τ) + r*δ`
([prover:304](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L304)):

{% highlight rust %}
// Aₚ = r*δ
let mut g_a = vk.delta_g1 * &r;
// Aₚ = α + r*δ
AddAssign::<&E::G1Affine>::add_assign(&mut g_a, &vk.alpha_g1);
let mut a_answer = a_inputs.wait()?;
AddAssign::<&E::G1>::add_assign(&mut a_answer, &a_aux.wait()?);
// Aₚ = α + A(τ) + r*δ
AddAssign::<&E::G1>::add_assign(&mut g_a, &a_answer);
{% endhighlight %}

Bₚ is computed in a [very similiar
way](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L306). What
is more interesting is Cₚ since it involves a more complex
`H(τ)*(T(τ)/δ)` expression. Recall that H(τ) is basically
`(A(t) * B(t) - C(t)) / T(t)` and `T(x)` is the target polynomial that
is public. Here is how it gets
[computed](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L211)
(`h` in the code represents `H(τ)*(T(τ)/δ)`:

{% highlight rust %}
let h = {
    let mut a = EvaluationDomain::from_coeffs(prover.a)?;
    let mut b = EvaluationDomain::from_coeffs(prover.b)?;
    let mut c = EvaluationDomain::from_coeffs(prover.c)?;
    a.ifft(&worker);
    a.coset_fft(&worker);
    b.ifft(&worker);
    b.coset_fft(&worker);
    c.ifft(&worker);
    c.coset_fft(&worker);

    // A * B
    a.mul_assign(&worker, &b);
    drop(b);
    // A * B - C
    a.sub_assign(&worker, &c);
    drop(c);
    // (A * B - C) / T
    a.divide_by_z_on_coset(&worker);
    a.icoset_fft(&worker);
    let mut a = a.into_coeffs();
    let a_len = a.len() - 1;
    a.truncate(a_len);
    // TODO: parallelize if it's even helpful
    let a = Arc::new(a.into_iter().map(|s| s.0).collect::<Vec<_>>());

    // ((A * B - C) / T) * (T / δ)
    multiexp(&worker, params.get_h(a.len())?, FullDensity, a)
};
{% endhighlight %}

Now the prover knows H(τ)*(T(τ)/δ), it becomes clearer how Cₚ is
[computed](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/prover.rs#L308):

{% highlight rust %}
let mut g_c;
{
    let mut rs = r;
    rs.mul_assign(&s);

    // Cₚ = r*s*δ
    g_c = vk.delta_g1 * &rs;

    // Cₚ = r*s*δ + s*α
    AddAssign::<&E::G1>::add_assign(&mut g_c, &(vk.alpha_g1 * &s));

    // Cₚ = r*s*δ + s*α + r*β
    AddAssign::<&E::G1>::add_assign(&mut g_c, &(vk.beta_g1 * &r));
}

// Cₚ = s*A(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut a_answer, s);
AddAssign::<&E::G1>::add_assign(&mut g_c, &a_answer);

// Cₚ = r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
MulAssign::<E::Fr>::mul_assign(&mut b1_answer, r);
AddAssign::<&E::G1>::add_assign(&mut g_c, &b1_answer);

// Cₚ = H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
AddAssign::<&E::G1>::add_assign(&mut g_c, &h.wait()?);

// Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β
AddAssign::<&E::G1>::add_assign(&mut g_c, &l.wait()?);
{% endhighlight %}

As we can see, Cₚ computed as
`L_aux(τ)/δ + H(τ)*(T(τ)/δ) + r*B(τ) + s*A(τ) + r*s*δ + s*α + r*β`,
which is actually equivalent to
`L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ`, as shown below:

{% highlight bash %}
# G2 elements
L_aux(τ) = ∑ wᵢLᵢ(τ)  # i in l+1..m. This is the aux input
Cₚ = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
   # Expand Aₚ and Bₚ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*(α + A(τ) + r*δ) + r*(β + B(τ) + s*δ) - r*s*δ
   = L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*α + s*A(τ) + r*β + r*B(τ) + r*s*δ
{% endhighlight %}

At this point, Aₚ, Bₚ and Cₚ are computed and prover completes the
proof.

## Verifier

The goal of the verifier is to take the proof, i.e. Aₚ, Bₚ and Cₚ, and
verify that the following equation holds:

{% highlight haskell %}
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
  where
    L_input(τ) = ∑ wᵢLᵢ(τ) -- i in 0..l
{% endhighlight %}

`L_input` is the public input.

To see what exactly what it means if this equation holds, we can try
to expand on the left hand side (LHS) and the right hand side (RHS) of
the equation.

#### LHS

`Aₚ*Bₚ` is equivalent to `A(τ)*B(τ) + REM`:

{% highlight haskell %}
Aₚ*Bₚ = A(τ)*B(τ) + REM
  where
    REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}

<details>
  <summary>Click here to see a more detailed deduction</summary>
{% highlight bash %}
Aₚ*Bₚ
# Expand Aₚ = (α + A(τ) + r*δ)
# Expand Bₚ = (β + B(τ) + s*δ)
= (α + A(τ) + r*δ) * (β + B(τ) + s*δ)
= α*β + α*B(τ) + α*s*δ + β*A(τ) + A(τ)*B(τ) + s*δ*A(τ) + r*β*δ + r*δ*B(τ) + r*s*δ*δ
= A(τ)*B(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= A(τ)*B(τ) + REM
{% endhighlight %}
</details>

#### RHS

`α*β + (L_input/γ)*γ + Cₚ*δ` is equivalent to `C(τ) + H(τ)*T(τ) + REM`:

{% highlight haskell %}
α*β + (L_input/y)*y + Cₚ*δ = C(τ) + H(τ)*T(τ) + REM
  where
    REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
{% endhighlight %}

<details>
  <summary>Click to see a more detailed deduction</summary>
{% highlight bash %}
α*β + (L_input/γ)*γ + Cₚ*δ
# expand Cₚ = L_aux/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ
= α*β + L_input(τ) + (L_aux(τ)/δ + H(τ)*(T(τ)/δ) + s*Aₚ + r*Bₚ - r*s*δ)*δ
= α*β + L_input(τ) + L_aux(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# L(τ) = L_input(τ) + L_aux(τ)
= α*β + L(τ) + H(τ)*T(τ) + s*δ*Aₚ + r*δ*Bₚ - r*s*δ*δ
# expand Aₚ = α + A(τ) + r*δ
# expand Bₚ = β + B(τ) + s*δ
= α*β + L(τ) + H(τ)*T(τ) + s*δ*(α + A(τ) + r*δ) + r*δ*(β + B(τ) + s*δ) - r*s*δ*δ
= α*β + L(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
# expand L(τ) = α*B(τ) + β*A(τ) + C(τ)
= α*β + α*B(τ) + β*A(τ) + C(τ) + H(τ)*T(τ) + α*s*δ + s*δ*A(τ) + r*s*δ*δ + r*β*δ + r*δ*B(τ)
= C(τ) + H(τ)*T(τ) + α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
# Let REM = α*β + α*B(τ) + β*A(τ) + α*s*δ + s*δ*A(τ) + r*δ*B(τ) + r*β*δ + r*s*δ*δ
= C(τ) + H(τ)*T(τ) + REM
{% endhighlight %}
</details>

What this means is that if we can prove `LHS = RHS`, then we have also
proved that `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` as shown below.

{% highlight bash %}
Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ
# Use the LHS and RHS deduction
A(τ)*B(τ) + REM = C(τ) + H(τ)*T(τ) + REM

# Hooray! This is what we want to prove!
A(τ)*B(τ) - C(τ) = H(τ)*T(τ)
{% endhighlight %}

Once `A(τ)*B(τ)-C(τ) = H(τ)*T(τ)` is proved to be true, the verifier
is confident that the program is executed faithfully with the correct
aux input.

### Implementation
The verification code in Bellman is located at
[verifier.rs](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L21). As
explained by the comments, the original equation
`Aₚ*Bₚ = α*β + (L_input(τ)/γ)*γ + Cₚ*δ` is converted to
`Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β`, which only requires one
final exponentiation ([verifier.rs:44](https://github.com/zkcrypto/bellman/blob/81f4aac8c7e96cd7957b8b7a27bb57e96fe2c2f8/src/groth16/verifier.rs#L44)).

{% highlight rust %}
// Code that proves:
// Aₚ*Bₚ + (L_input(τ)/γ)*(-γ) + Cₚ*(-δ) = α*β

Ok(E::final_exponentiation(&E::miller_loop(
    [
        // Aₚ*Bₚ
        (&proof.a.prepare(), &proof.b.prepare()),
        // (L_input(τ)/γ)*(-γ)
        (&acc.into_affine().prepare(), &pvk.neg_gamma_g2),
        // Cₚ*(-δ)
        (&proof.c.prepare(), &pvk.neg_delta_g2),
    ]
    .iter(),
))
.unwrap()
    // α*β
    == pvk.alpha_g1_beta_g2)
{% endhighlight %}
